import{e as i,a1 as o,a0 as d,r as u,j as h,i as j,ax as k}from"./index-22564d29.js";function M(a,t=[],s="Start"){if(!t.includes(a))return s;let r;switch(a){case o.Done:r="Done";break;case o.Running:r="Running...";break;case o.Applying:r="Applying...";break;case o.Cancelling:r="Cancelling...";break;case o.Resetting:r="Resetting...";break;case o.Run:r="Run";break;case o.Apply:r="Apply";break;default:r=s;break}return r}function E(a){return Object.values(a??{}).some(i)}function I({planAction:a,planState:t,hasBackfills:s,hasVirtualUpdate:r,hasNoChanges:e,skip_backfill:c}){return c?"Skipping Backfill":a===o.Running?"Collecting Backfill...":t===d.Applying&&s?"Backfilling...":t===d.Applying&&r?"Applying...":t===d.Failed?"Failed":t===d.Cancelled?"Cancelled":t===d.Finished&&s?"Completed Backfill":t===d.Finished&&r?"Completed Virtual Update":s?"Needs Backfill":r?"Virtual Update Will Be Applied":e?"No Changes":"Updating..."}const n={ResetPlanOptions:"reset-plan-options",ResetBackfills:"reset-backfills",ResetChanges:"reset-changes",ResetTestsReport:"reset-tests-report",Dates:"dates",DateStart:"date-start",DateEnd:"date-end",Category:"category",Backfills:"backfills",BackfillProgress:"backfill-progress",Changes:"changes",PlanOptions:"plan-options",External:"external",TestsReportErrors:"tests-report-errors",TestsReportMessages:"tests-report-messages"},D={Add:"add",Remove:"remove",Direct:"direct",Indirect:"indirect",Metadata:"metadata"},b={BreakingChange:"breaking-change",NonBreakingChange:"non-breaking-change"},[m,R]=A(),f={start:void 0,end:void 0,skip_tests:!1,no_gaps:!1,skip_backfill:!1,forward_only:!1,auto_apply:!1,no_auto_categorization:!1,include_unmodified:!0,from:void 0,restate_models:void 0,create_from:void 0,categories:R,defaultCategory:m,change_categorization:new Map,hasChanges:!1,hasDirect:!1,hasIndirect:!1,hasMetadata:!1,hasAdded:!1,hasRemoved:!1,added:[],removed:[],modified:{direct:[],indirect:[],metadata:[]},hasVirtualUpdate:!1,virtualUpdateDescription:"All changes and their downstream dependencies can be fully previewed before they get promoted. If during plan creation no data gaps have been detected and only references to new model versions need to be updated, then such an update is referred to as a Virtual Update. Virtual Updates impose no additional runtime overhead or cost.",activeBackfill:void 0,hasBackfills:!1,backfills:[],isInitialPlanRun:!1,errors:[],testsReportErrors:void 0,testsReportMessages:void 0},v=u.createContext(f),C=u.createContext(()=>{});function N({children:a}){const[t,s]=u.useReducer(O,Object.assign(f));return h.jsx(v.Provider,{value:Object.assign(t),children:h.jsx(C.Provider,{value:s,children:a})})}function U(){return u.useContext(v)}function T(){return u.useContext(C)}function O(a,t){return t=Array.isArray(t)?t:[t],t.reduce(P,a)}function P(a=f,{type:t,...s}){var r;switch(t){case n.ResetPlanOptions:return Object.assign({},a,{skip_tests:!1,no_gaps:!1,skip_backfill:!1,forward_only:!1,auto_apply:!1,no_auto_categorization:!1,include_unmodified:!0,create_from:void 0,restate_models:void 0});case n.PlanOptions:return Object.assign({},a,s);case n.ResetBackfills:return Object.assign({},a,{hasVirtualUpdate:!1,activeBackfill:void 0,hasBackfills:!1,backfills:[]});case n.ResetChanges:return Object.assign({},a,{hasChanges:!1,hasDirect:!1,hasIndirect:!1,hasMetadata:!1,hasAdded:!1,hasRemoved:!1,added:[],removed:[],modified:{direct:[],indirect:[],metadata:[]}});case n.Dates:return Object.assign({},a,{start:s.start,end:s.end});case n.External:return Object.assign({},a,{isInitialPlanRun:s.isInitialPlanRun??!1});case n.DateStart:return Object.assign({},a,{start:s.start});case n.DateEnd:return Object.assign({},a,{end:s.end});case n.BackfillProgress:return Object.assign({},a,{activeBackfill:s.activeBackfill});case n.Backfills:{const e=s.backfills;return Object.assign({},a,{backfills:e??[],hasBackfills:i(e),hasVirtualUpdate:j(e)})}case n.TestsReportErrors:return Object.assign({},a,{testsReportErrors:s.testsReportErrors});case n.TestsReportMessages:return Object.assign({},a,{testsReportMessages:s.testsReportMessages});case n.ResetTestsReport:return Object.assign({},a,{testsReportErrors:void 0,testsReportMessages:void 0});case n.Category:{const{change:e,category:c}=s;return(e==null?void 0:e.model_name)!=null&&a.change_categorization.set(e.model_name,{category:c,change:e}),Object.assign({},a,{change_categorization:new Map(a.change_categorization)})}case n.Changes:{const{modified:e,added:c=[],removed:g=[]}=s,y=[E(e),i(c),i(g)].some(Boolean),p=new Map;return(r=e==null?void 0:e.direct)==null||r.forEach(l=>{if((l==null?void 0:l.model_name)!=null){const _=R.find(B=>B.value===l.change_category);p.set(l.model_name,{change:l,category:_??m})}}),Object.assign({},a,{modified:{direct:(e==null?void 0:e.direct)??[],indirect:(e==null?void 0:e.indirect)??[],metadata:(e==null?void 0:e.metadata)??[]},added:c,removed:g,hasChanges:y,hasDirect:i(e==null?void 0:e.direct),hasIndirect:i(e==null?void 0:e.indirect),hasMetadata:i(e==null?void 0:e.metadata),hasAdded:i(c),hasRemoved:i(g)},{change_categorization:p})}default:return Object.assign({},a)}}function A(){const a={id:b.BreakingChange,name:"Breaking Change",description:"It will rebuild all models",value:k.NUMBER_1},t=[a,{id:b.NonBreakingChange,name:"Non-Breaking Change",description:"It will exclude all indirect models caused by this change",value:k.NUMBER_2}];return[a,t]}export{D as E,N as P,M as a,T as b,n as c,I as g,E as i,U as u};
